options {
  // Parser options
  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  // Parser class name and namespace
  parserPackage="JetBrains.ReSharper.Plugins.Yaml.Psi.Gen";
  parserClassName="YamlParserGenerated";

  // Strongly type the lexer we're using. ILexer<int> is the caching lexer instance
  "lexerClassName"="JetBrains.ReSharper.Psi.Parsing.ILexer<int>";

  // FQN of (non-generated) class that provides messages for the parser
  parserMessagesClass="JetBrains.ReSharper.Plugins.Yaml.Psi.Parsing.ParserMessages";

  // Parser, error messages + token bitsets target folder
  parserTargetSubdir="Parsing/Yaml";

  // Don't generate a bitset unless there's 4 or more comparisons to be made
  tokenBitsetThreshold=4;

  // Composite node type/element generation options
  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  // Existing language specific ITreeNode
  "psiElementClassFQName"="JetBrains.ReSharper.Plugins.Yaml.Psi.Tree.IYamlTreeNode";

  // Existing token type containing class + namespace
  tokenTypePackageName="JetBrains.ReSharper.Plugins.Yaml.Psi.Parsing";
  tokenTypeClassName="YamlTokenType";

  // Set base index for generated (element, not token) node types. Defaults to 2000, tokens default to 1000
  // tokenTypeBaseIndex=2000;

  // Tree node interface namespace + target folder (also target folder for navigators + visitors)
  psiInterfacePackageName="JetBrains.ReSharper.Plugins.Yaml.Psi.Tree";
  psiInterfacesTargetSubdir="Psi/Yaml/Tree";

  // Tree node implementation namespace, base type and target folder
  psiStubsPackageName="JetBrains.ReSharper.Plugins.Yaml.Psi.Tree.Impl";
  psiStubsBaseClass="YamlCompositeElement";
  psiStubsTargetSubdir="Psi/Yaml/Tree/Impl";

  // Existing composite node type base class
  elementTypeBaseClass="YamlCompositeNodeType";

  // Namespace for generating custom interface when `customInterface` option used
  customInterfacePackage="JetBrains.ReSharper.Plugins.Yaml.Psi.Tree";

  // Any role used in this file that begins with this prefix must be defined in `ChildRole`
  publicChildRolePrefix="YAML_";


  // Namespace and suffix for custom element instance implementation created by
  // node type when `customImpl` option is specfied.
  // Default suffix is `Impl`
  customImplPackage="JetBrains.ReSharper.Plugins.Yaml.Psi.Tree.Impl";
  "customImplSuffix"="";


  // Required on. Changes behaviour of various things, e.g. public child role values based on prefix
  disableReflection;

  // Required. If missing, generates Add/Remove methods for each collection
  generateWorkingPsi;
}


// **************************************************************************
//
// Note that this file describes the shape of the PSI, not how to parse YAML.
// The order of items in the elements does not always match what's requried
// in the file. And the repetition values can be more complex than they seem.
// E.g. blockHeader has chomping and indentation indicators. These can be in
// any order, and are both marked as optional. We'd expect at least one to be
// provided if we were adding the blockHeader node. The parser handles this.
//
// **************************************************************************


// **************************************************************************
//
// File (streams and documents)
//
// **************************************************************************

yamlFile
options {
  stubBase="YamlFileElement";
}
:
  yamlDocument<DOCUMENT, Documents>*
;

yamlDocument
:
  directives<DIRECTIVES, Directives>?
  //blockNode
  
  // TODO: Documents must either be separated with one or more document end markers or directive end marker
  // We can't easily capture that without using interface, and I don't want to do that
  DOCUMENT_END<DOCUMENT_END, DocumentEndMarker>*
;


// **************************************************************************
//
// Directives
//
// **************************************************************************

directives
: 
  directive<DIRECTIVE, Directive>+
  DIRECTIVES_END<DIRECTIVES_END, DirectivesEndMarker>*
;

directive
:
  PERCENT<PERCENT, Percent>
  NS_CHARS<NAME, Name>
  NS_CHARS<PARAMETERS, Parameters>*
;


// **************************************************************************
//
// Nodes
//
// **************************************************************************

interface node
:
  // Block scalars
  literalScalarNode
  | foldedScalarNode

  // Flow scalars
  | aliasNode
  | plainScalarNode
  | singleQuotedScalarNode
  | doubleQuotedScalarNode
;

nodeProperties
:
  tagProperty<TAG_PROPERTY, TagProperty>?
  anchorProperty<ANCHOR_PROPERTY, AnchorProperty>?
;

interface tagProperty
:
  verbatimTagProperty
  | shorthandTagProperty
  | nonSpecificTagProperty
;

verbatimTagProperty
:
  BANG_LT<BANG_LT_INDICATOR, BangLtIndicator>
  NS_URI_CHARS<TEXT, Text>
  GT<GT_INDICATOR, GtIndicator>
;

shorthandTagProperty
:
  tagHandle<TAG_HANDLE, TagHandle>
  NS_TAG_CHARS<TEXT, Text>
;

nonSpecificTagProperty
:
  BANG<BANG_INDICATOR, BangIndicator>
;

interface tagHandle
:
  namedTagHandle
  | secondaryTagHandle
  | primaryTagHandle
;

namedTagHandle
:
  BANG<BANG_INDICATOR, BangIndicator>
  (
    // TODO: Merge NS_WORD_CHARS and NS_TAG_CHARS tokens?
    NS_WORD_CHARS<TEXT, Text>
    | NS_TAG_CHARS<TEXT, Text>
  )?
  BANG<BANG_INDICATOR, EndBangIndicator>
;

secondaryTagHandle
:
  BANG<BANG_INDICATOR, BangIndicator>
  BANG<BANG_INDICATOR, EndBangIndicator>
;

primaryTagHandle
:
  BANG<BANG_INDICATOR, BangIndicator>
;

anchorProperty
:
  AMP<AMP_INDICATOR, AmpIndicator>
  NS_ANCHOR_NAME<TEXT, Text>
;


// **************************************************************************
//
// Block scalar nodes
//
// **************************************************************************

blockHeader
:
  chompingIndicator<CHOMPING_INDICATOR, ChompingIndicator>?
  indentationIndicator<INDENTATION_INDICATOR, IndentationIndicator>?
;

chompingIndicator
:
  PLUS<PLUS, Plus>
  | MINUS<MINUS, Minus>
;

indentationIndicator
:
  NS_DEC_DIGIT<DIGIT, Digit>
;

literalScalarNode
:
  PIPE<INDICATOR, PipeIndicator>
  blockHeader<BLOCK_HEADER, BlockHeader>?
  SCALAR_TEXT<TEXT, Text>+
;

foldedScalarNode
:
  GT<INDICATOR, GtIndicator>
  blockHeader<BLOCK_HEADER, BlockHeader>?
;


// **************************************************************************
//
// Flow scalar nodes
//
// **************************************************************************

aliasNode
:
  ASTERISK<ASTERISK, Asterisk>
  NS_ANCHOR_NAME<ANCHOR_NAME, AnchorName>
;

plainScalarNode
:
  // TODO: INDENTS!!!!
  NS_PLAIN_ONE_LINE<TEXT, Text>
  | NS_PLAIN_MULTI_LINE<TEXT, Text>
;

singleQuotedScalarNode
:
  C_SINGLE_QUOTED_SINGLE_LINE<TEXT, Text>
  | C_SINGLE_QUOTED_MULTI_LINE<TEXT, Text>
;

doubleQuotedScalarNode
:
  C_DOUBLE_QUOTED_SINGLE_LINE<TEXT, Text>
  | C_DOUBLE_QUOTED_MULTI_LINE<TEXT, Text>
;
