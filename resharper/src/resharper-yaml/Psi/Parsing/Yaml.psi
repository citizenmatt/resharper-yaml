options {
  // Parser options
  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  // Parser class name and namespace
  parserPackage="JetBrains.ReSharper.Plugins.Yaml.Psi.Gen";
  parserClassName="YamlParserGenerated";

  // Strongly type the lexer we're using. ILexer<int> is the caching lexer instance
  "lexerClassName"="JetBrains.ReSharper.Psi.Parsing.ILexer<int>";

  // FQN of (non-generated) class that provides messages for the parser
  parserMessagesClass="JetBrains.ReSharper.Plugins.Yaml.Psi.Parsing.ParserMessages";

  // Parser, error messages + token bitsets target folder
  parserTargetSubdir="Parsing/Yaml";

  // Don't generate a bitset unless there's 4 or more comparisons to be made
  tokenBitsetThreshold=4;


  // Composite node type/element generation options
  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  // Existing language specific ITreeNode
  "psiElementClassFQName"="JetBrains.ReSharper.Plugins.Yaml.Psi.Tree.IYamlTreeNode";

  // Existing token type containing class + namespace
  tokenTypePackageName="JetBrains.ReSharper.Plugins.Yaml.Psi.Parsing";
  tokenTypeClassName="YamlTokenType";

  // Set base index for generated (element, not token) node types. Defaults to 2000, tokens default to 1000
  // tokenTypeBaseIndex=2000;

  // Tree node interface namespace + target folder (also target folder for navigators + visitors)
  psiInterfacePackageName="JetBrains.ReSharper.Plugins.Yaml.Psi.Tree";
  psiInterfacesTargetSubdir="Psi/Yaml/Tree";

  // Tree node implementation namespace, base type and target folder
  psiStubsPackageName="JetBrains.ReSharper.Plugins.Yaml.Psi.Tree.Impl";
  psiStubsBaseClass="YamlCompositeElement";
  psiStubsTargetSubdir="Psi/Yaml/Tree/Impl";

  // Existing composite node type base class
  elementTypeBaseClass="YamlCompositeNodeType";

  // Namespace for generating custom interface when `customInterface` option used
  customInterfacePackage="JetBrains.ReSharper.Plugins.Yaml.Psi.Tree";

  // Any role used in this file that begins with this prefix must be defined in `ChildRole`
  publicChildRolePrefix="YAML_";


  // Namespace and suffix for custom element instance implementation created by
  // node type when `customImpl` option is specfied.
  // Default suffix is `Impl`
  customImplPackage="JetBrains.ReSharper.Plugins.Yaml.Psi.Tree.Impl";
  "customImplSuffix"="";


  // Required on. Changes behaviour of various things, e.g. public child role values based on prefix
  disableReflection;

  // Required. If missing, generates Add/Remove methods for each collection
  generateWorkingPsi;
}


// **************************************************************************
//
// File (streams and documents)
//
// **************************************************************************

errorhandling yamlFile
options {
  stubBase="YamlFileElement";
}
:
  yamlDocument<DOCUMENT, Documents>*
;

yamlDocument
:
  directives<DIRECTIVES, Directives>?
  (
    blockNode?
    | eatUpToDocEndMarker
  )*
  // Documents must be separated by either one or more document end markers, or a directives end marker
  // We can't easily represent that here as it requires knowledge of the following token
  // TODO: Add an inspection to make sure there is correct separation of documents
  DOCUMENT_END<DOCUMENT_END, DocumentEndMarker>*
;


// **************************************************************************
//
// Directives
//
// **************************************************************************

directives
: 
  (
    directive<DIRECTIVE, Directive>+
    DIRECTIVES_END<DIRECTIVES_END, DirectivesEndMarker>+
  )
  | DIRECTIVES_END<DIRECTIVES_END, DirectivesEndMarker>*
;

directive
:
  PERCENT<PERCENT, Percent>
  NS_CHARS<NAME, Name>
  NS_CHARS<PARAMETERS, Parameters>*
;


// **************************************************************************
//
// Nodes
//
// **************************************************************************

private blockNode
:
  blockInBlockNode
  | flowInBlockNode
;

private blockInBlockNode
:
  blockScalarNode
  // | blockCollectionNode
;

private blockScalarNode
:
  literalScalarNode
  | foldedScalarNode
;

private flowInBlockNode
:
  aliasNode
  | plainScalarNode
  | singleQuotedScalarNode
  | doubleQuotedScalarNode
  // | flowSequenceNode
  // | flowMappingNode
;


// **************************************************************************
//
// Node interface
//
// **************************************************************************

interface node
:
  // Block nodes
  literalScalarNode
  | foldedScalarNode

  // Flow nodes
  | aliasNode
  | plainScalarNode
  | singleQuotedScalarNode
  | doubleQuotedScalarNode
;


// **************************************************************************
//
// Block nodes
//
// **************************************************************************

blockHeader
:
  (
    chompingIndicator<CHOMP, ChompingIndicator>
    indentationIndicator<INDENTATION, IndentationIndicator>?
  )
  |
  (
    indentationIndicator<INDENTATION, IndentationIndicator>
    chompingIndicator<CHOMP, ChompingIndicator>?
  )
;

chompingIndicator
:
  PLUS<PLUS, Plus>
  | MINUS<MINUS, Minus>
;

indentationIndicator
:
  NS_DEC_DIGIT<DIGIT, Digit>
;

literalScalarNode
:
  PIPE<INDICATOR, PipeIndicator>
  blockHeader<HEADER, BlockHeader>?
  SCALAR_TEXT<TEXT, Text>+
;

foldedScalarNode
:
  GT<INDICATOR, GtIndicator>
  blockHeader<HEADER, BlockHeader>?
  SCALAR_TEXT<TEXT, Text>+
;



// **************************************************************************
//
// Flow nodes
//
// **************************************************************************

aliasNode
:
  ASTERISK<ASTERISK, Asterisk>
  NS_ANCHOR_NAME<ANCHOR_NAME, AnchorName>
;

plainScalarNode
:
  // TODO: Handle indents
  NS_PLAIN_ONE_LINE<SINGLE_LINE, SingleLine>
  | NS_PLAIN_MULTI_LINE<MULTI_LINE, MultiLine>
;

singleQuotedScalarNode
:
  C_SINGLE_QUOTED_SINGLE_LINE<SINGLE_LINE, SingleLine>
  | C_SINGLE_QUOTED_MULTILINE<MULTI_LINE, MultiLine>
;

doubleQuotedScalarNode
:
  C_DOUBLE_QUOTED_SINGLE_LINE<SINGLE_LINE, SingleLine>
  | C_DOUBLE_QUOTED_MULTILINE<MULTI_LINE, MultiLine>
;



// **************************************************************************
//
// Misc
//
// **************************************************************************

abstract eatUpToDocEndMarker
options {
  interfaceName = "JetBriains.ReSharper.Psi.Tree.IErrorElement";
  elementType = "ERROR_ELEMENT";
}
:
  // Content first tokens
  INDENT
  | COLON
  | MINUS
  | LBRACE
  | LBRACK
  | GT
  | BANG
  | BANG_LT
  | NS_PLAIN_ONE_LINE
  | NS_PLAIN_MULTI_LINE
;


abstract unparsedError
options {
  interfaceName = "JetBriains.ReSharper.Psi.Tree.IErrorElement";
  elementType = "ERROR_ELEMENT";
}
:
  // Whatever
  INDENT
  | COLON
  | MINUS
  | LBRACE
  | LBRACK
  | GT
  | BANG
  | BANG_LT
  | NS_PLAIN_ONE_LINE
  | NS_PLAIN_MULTI_LINE
;
